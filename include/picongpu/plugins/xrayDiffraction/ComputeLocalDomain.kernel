/* Copyright 2013-2020 Axel Huebl, Heiko Burau, Rene Widera, Richard Pausch,
 *                     Klaus Steiniger, Felix Schmitt, Benjamin Worpitz,
 *                     Juncheng E, Sergei Bastrakov
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"

#include "picongpu/plugins/xrayDiffraction/ReciprocalSpace.hpp"

#include <pmacc/dimensions/DataSpaceOperations.hpp>
#include <pmacc/mappings/threads/ForEachIdx.hpp>
#include <pmacc/mappings/threads/IdxConfig.hpp>
#include <pmacc/math/Complex.hpp>
#include <pmacc/memory/Array.hpp>
#include <pmacc/memory/shared/Allocate.hpp>

#include <cstdint>


namespace picongpu
{
namespace plugins
{
namespace xrayDiffraction
{
namespace detail
{

    //! Complex type to represent structure factor values
    using Complex = pmacc::math::Complex< float_X >;

    //! Internal representation of results for each thread
    struct Result
    {
        //! Structure factor value F(q) for a single scattering vector
        Complex structureFactor = Complex::zero();
        
        //! Number of processed macroparticles
        uint64_t numMacroparticles = 0u;

        //! Combined weighting of processed macroparticles
        float_64 totalWeighting = 0.0;
        
        //! Combine the current result with another one
        Result & operator+=( Result const & other )
        {
            structureFactor += other.structureFactor;
            numMacroparticles += other.numMacroparticles;
            totalWeighting += other.totalWeighting;
            return *this;
        }

    };
 
    /** Process particles of a supercell
     *
     * @tparam T_numWorkers number of workers
     * @tparam T_Acc alpaka accelerator type
     * @tparam T_ParticleBox particle box type
     * @tparam T_Mapping mapping description type
     * @tparam T_CachedPositionArray cached array of positions type
     * @tparam T_CachedWeightingArray cached array of weighting type
     *
     * @param acc alpaka accelerator
     * @param idx supercell index with guard
     * @param localDomainOffset offset of the local domain
     * @param mapper mapping description
     * @param particleBox particle box
     * @param cachedPosition positions array in shared memory
     * @param cachedWeighting weighting array in shared memory
     * @param reciprocalSpace reciprocal space of scattering vectors
     */
    template<
        uint32_t T_numWorkers,
        typename T_Acc,
        typename T_ParticleBox,
        typename T_Mapping,
        typename T_CachedPositionArray,
        typename T_CachedWeightingArray
    >
    DINLINE Result processSupercell(
        T_Acc const & acc,
        DataSpace< simDim > const & idx,
        DataSpace< simDim > const & localDomainOffset,
        T_Mapping mapper,
        T_ParticleBox particleBox,
        T_CachedPositionArray & cachedPosition,
        T_CachedWeightingArray & cachedWeighting,
        ReciprocalSpace const & reciprocalSpace
    )
    {
        Result result;
        auto const guardingSuperCells = mapper.getGuardingSuperCells();
        auto const offset = localDomainOffset +
            ( ( idx - guardingSuperCells ) * SuperCellSize::toRT() );
        auto frame = particleBox.getLastFrame( idx );
        auto particlesInFrame = particleBox.getSuperCell( idx ).getSizeLastFrame();
        while( frame.isValid() )
        {
            auto frameResult = processFrame< T_numWorkers >(
                acc,
                frame,
                particlesInFrame,
                cachedPosition,
                cachedWeighting,
                offset,
                reciprocalSpace
            );
            result += frameResult;
            frame = particleBox.getPreviousFrame( frame );
            particlesInFrame = pmacc::math::CT::volume< SuperCellSize >::type::value;
            /// fix computation from particle box
            __syncthreads();
        }
        /// this line should not be needed it seems, as it sets the same value
        result.numMacroparticles = particleBox.getSuperCell( idx ).getNumParticles();
        return result;
    }

    /** Process particles of a frame
     *
     * @tparam T_numWorkers number of workers
     * @tparam T_Acc alpaka accelerator type
     * @tparam T_Frame particle frame type
     * @tparam T_CachedPositionArray cached array of positions type
     * @tparam T_CachedWeightingArray cached array of weighting type
     *
     * @param acc alpaka accelerator
     * @param frame particle frame
     * @param numParticles number of macroparticles in frame
     * @param particleBox particle box
     * @param cachedPosition positions array in shared memory
     * @param cachedWeighting weighting array in shared memory
     * @param supercellOffsetGlobal supercell offset in the global domain
     * @param reciprocalSpace reciprocal space of scattering vectors
     */
    template<
        uint32_t T_numWorkers,
        typename T_Acc,
        typename T_Frame,
        typename T_CachedPositionArray,
        typename T_CachedWeightingArray
    >
    DINLINE Result processFrame(
        T_Acc const & acc,
        T_Frame const & frame,
        uint32_t const numParticles,
        T_CachedPositionArray & cachedPosition,
        T_CachedWeightingArray & cachedWeighting,
        DataSpace< simDim > const & supercellOffsetGlobal,
        ReciprocalSpace const & reciprocalSpace
    )
    {
        uint32_t const workerIdx = threadIdx.x;
        uint32_t const globalWorkerIdx = blockIdx.x * blockDim.x + threadIdx.x;
        using namespace pmacc::mappings::threads;

        // Cache particle data of this frame to shared memory
        constexpr uint32_t frameSize =
            pmacc::math::CT::volume< SuperCellSize >::type::value;
        /// fix computation from particle box

        using ParticleDomCfg = IdxConfig<
            frameSize,
            T_numWorkers
        >;
        ForEachIdx< ParticleDomCfg > forEachParticle{ workerIdx };
        forEachParticle([&](uint32_t const linearIdx, uint32_t const)
        {
            if( linearIdx < numParticles )
            {
                auto particle = frame[ linearIdx ];
                auto const cellIdx = particle[ localCellIdx_ ];
                auto const pos = particle[ position_ ];
                // calculate global position of cell
                DataSpace<simDim> const globalPos(
                    supercellOffsetGlobal +
                    DataSpaceOperations<simDim>::template map<
                    SuperCellSize>(cellIdx));
                // Set z component to zero for 2D
                cachedPosition[ linearIdx ][ 2 ] = 0.0;
                for( auto dim = 0u; dim < simDim; ++dim )
                    cachedPosition[ linearIdx ][ dim ] =
                    (static_cast< float_X >(globalPos[dim]) + pos[dim]) * cellSize[dim];
                cachedWeighting[ linearIdx ] = particle[ weighting_ ];

            }
        });

        __syncthreads(); // wait till every thread has loaded its
                         // particle data

        // conversion multiplier from PIC unit length to angstrom
        constexpr float_X meter2angstrom = 1e10_X;
        constexpr float_X lengthToAngstrom = meter2angstrom * UNIT_LENGTH;

        auto const q = reciprocalSpace.getValue( globalWorkerIdx );

        // Particle loop: thread runs through loaded particle data
        Result result;
        result.numMacroparticles = numParticles;
        for( auto particleIdx = 0u; particleIdx < numParticles; ++particleIdx )
        {
            auto const dotkr = math::dot(
                q,
                cachedPosition[ particleIdx ]
            ) * lengthToAngstrom;
            float_X sinValue, cosValue;
            math::sincos(
                dotkr,
                sinValue,
                cosValue
            );
            result.structureFactor += Complex( cosValue, sinValue ) * cachedWeighting[ particleIdx ];
            result.totalWeighting += cachedWeighting[ particleIdx ];
        }
        return result;
    }

    /** calculate the scattering of a species
     *
     * @tparam T_numWorkers number of workers
     */
    template< uint32_t T_numWorkers >
    struct KernelXrayDiffraction
    {
        /**
         * The SAXS kernel calculates for all particles on the device the
         * scattering intensity for input calculation ranges.
         * The parallelization is as follows:
         *  - The number of threads per block is equal to the number of cells per
         *    super cells which is also equal to the number of particles per frame
         *
         * The procedure starts with calculating unique ids for the threads and
         * initializing the shared memory.
         * Then a loop over all super cells starts.
         * Every thread loads a particle from that super cell and calculates its
         * scattering structure factor.
         * For every Particle
         * exists therefore a unique space within the shared memory.
         * After that, a thread calculates for a specific scattering vector of all
         * particles.
         */
        template <
            typename ParBox,
            typename DBox,
            typename DBox_nmp,
            typename DBox_np,
            typename Mapping,
            typename T_Acc>
        DINLINE
        void
        operator()(
            T_Acc const &acc,
            ParBox pb,
            DBox structureFactor,
            DBox_nmp numMacroparticles,
            DBox_np totalWeighting,
            DataSpace< simDim > localDomainOffset,
            Mapping mapper,
            ReciprocalSpace const & reciprocalSpace
        ) const
        {
            constexpr uint32_t frameSize =
                pmacc::math::CT::volume< SuperCellSize >::type::value; /// fix computation from particle box

            // vectorial part of the integrand in the Jackson formula
            using PositionArray = memory::Array<
                float3_X,
                frameSize
            >;
            PMACC_SMEM(
                acc,
                cachedR,
                PositionArray
            );

            using WeightingArray = memory::Array<
                float_X,
                frameSize
            >;
            PMACC_SMEM(
                acc,
                cachedWeighting,
                WeightingArray
            );


            /* number of super cells on GPU per dimension (still including guard
             * cells) remove both guards from count [later one sided guard needs to
             * be added again]
             */
            auto const guardingSuperCells = mapper.getGuardingSuperCells();
            auto const superCellsCount =
                mapper.getGridSuperCells() - 2 * guardingSuperCells;

            // get absolute number of relevant super cells
            auto const numSuperCells = superCellsCount.productOfComponents();

            detail::Result result;
            for( auto supercellLinearIdx = 0; supercellLinearIdx < numSuperCells; ++supercellLinearIdx )
            {             
                auto const idxWithGuard = DataSpaceOperations< simDim >::map(
                    superCellsCount,
                    supercellLinearIdx
                ) + guardingSuperCells;

                auto const supercellResult = detail::processSupercell< T_numWorkers >(
                    acc,
                    idxWithGuard,
                    localDomainOffset,
                    mapper,
                    pb,
                    cachedR,
                    cachedWeighting,
                    reciprocalSpace
                );
               /* Note: summing up for each supercell separately and adding
                * to the total has an added benefit of reducing summation errors
                * compared to a straighforward summation
                */
                result += supercellResult;           
            }

            // write results to global memory
            auto const globalWorkerIdx = blockIdx.x * blockDim.x + threadIdx.x;
            structureFactor[ globalWorkerIdx ] = result.structureFactor;
            // total weight of particles is written by a single thread per GPU
            if( globalWorkerIdx == 0 )
            {
                numMacroparticles[ 0 ] = result.numMacroparticles;
                totalWeighting[ 0 ] = result.totalWeighting;
            }

        }
    };

} // namespace detail
} // namespace xrayDiffraction
} // namespace plugins
} // namespace picongpu

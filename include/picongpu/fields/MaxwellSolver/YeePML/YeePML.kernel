/* Copyright 2013-2019 Axel Huebl, Heiko Burau, Rene Widera, Marco Garten,
 *                     Sergei Bastrakov
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"
#include "picongpu/fields/MaxwellSolver/YeePML/Parameters.hpp"
#include <pmacc/algorithms/math/floatMath/floatingPoint.tpp>
#include <pmacc/mappings/threads/ForEachIdx.hpp>
#include <pmacc/mappings/threads/IdxConfig.hpp>
#include <pmacc/mappings/threads/ThreadCollective.hpp>
#include <pmacc/memory/boxes/CachedBox.hpp>


namespace picongpu
{
namespace fields
{
namespace maxwellSolver
{
namespace yeePML
{

    //! Parameters of PML for the local domain
    struct LocalParameters : public Parameters
    {
        //! PML size in cells, stored as floats to avoid type casts later
        floatD_X const negativeBorderSize;
        floatD_X const positiveBorderSize;

        //! Local domain characteristics, including guard cells
        DataSpace< simDim > const numLocalDomainCells;
        DataSpace< simDim > const numGuardCells;

        LocalParameters(
            Parameters const parameters,
            Thickness const localThickness,
            DataSpace< simDim > const numLocalDomainCells,
            DataSpace< simDim > const numGuardCells
        ):
            Parameters( parameters ),
            negativeBorderSize( precisionCast< float_X >( localThickness.negativeBorder ) ),
            positiveBorderSize( precisionCast< float_X >( localThickness.positiveBorder ) ),
            numLocalDomainCells( numLocalDomainCells ),
            numGuardCells( numGuardCells )
        {
        }
    };

    namespace detail
    {
        /* Get relative depth of a given index in PML for 1D.
         * Index and local domain size include the guard.
         * So index == numGuardCells corresponds to the external negative PML
         * border, and index == numLocalDomainCells - numGuardCells - 1 
         * corresponds to the external positive PML border.
         * For the internal area result is 0, for points in PML the depth
         * scales from 0 at the internal border to 1 at the external border.
         */
        DINLINE float_X getRelativeDepth(
            float_X const index,
            float_X const numPMLCellsNegative,
            float_X const numPMLCellsPositive,
            uint32_t const numLocalDomainCells,
            uint32_t const numGuardCells
        )
        {
            auto zeroBasedIndex = index - numGuardCells;
            float_X result = 0.0_X;
            auto zeroBasedRightPMLStart = numLocalDomainCells -
                2 * numGuardCells - numPMLCellsPositive;
            if( zeroBasedIndex < numPMLCellsNegative )
                result = ( numPMLCellsNegative - zeroBasedIndex ) / numPMLCellsNegative;
            else if( zeroBasedIndex > zeroBasedRightPMLStart )
                result = ( zeroBasedIndex - zeroBasedRightPMLStart ) / numPMLCellsPositive;
            return result;
        }

        /* Get absorption parameters: sigma, kappa and alpha
         * Index and local domain size include the guard.
         */
        DINLINE void getAbsorptionParameters(
            floatD_X cellIdx,
            LocalParameters const parameters,
            float3_X & normalizedSigma,
            float3_X & kappa,
            float3_X & normalizedAlpha
        )
        {
            // initialize with values for non-PML area
            normalizedSigma = float3_X::create( 0._X );
            kappa = float3_X::create( 1._X );
            normalizedAlpha = float3_X::create( 0._X );
            for( auto dim = 0; dim < simDim; dim++ )
            {
                auto const relativeDepth = getRelativeDepth(
                    cellIdx[ dim ],
                    parameters.negativeBorderSize[ dim ],
                    parameters.positiveBorderSize[ dim ],
                    parameters.numLocalDomainCells[ dim ],
                    parameters.numGuardCells[ dim ]
                );
                // Since normally most points are not in PML, avoid costly
                // computing in this case
                if( relativeDepth != 0._X )
                {
                    auto const sigmaKappaGradingCoeff = math::pow(
                        relativeDepth,
                        parameters.sigmaKappaGradingOrder
                    );
                    normalizedSigma[ dim ] = parameters.normalizedSigmaMax[ dim ] *
                        sigmaKappaGradingCoeff;
                    kappa[ dim ] = 1._X + ( parameters.kappaMax[ dim ] - 1._X ) *
                        sigmaKappaGradingCoeff;
                    // note that this is only correct when relativeDepth != 0
                    auto const alphaGradingCoeff = math::pow(
                        1._X - relativeDepth,
                        parameters.sigmaKappaGradingOrder
                    );
                    normalizedAlpha[ dim ] = parameters.normalizedAlphaMax[ dim ] *
                        alphaGradingCoeff;
                }
            }
        }

        DINLINE void getCoefficients(
            floatD_X idx,
            LocalParameters const parameters,
            float_X const dt,
            float3_X & kappa,
            float3_X & damping,
            float3_X & diff
        )
        {
            float3_X normalizedSigma, normalizedAlpha;
            getAbsorptionParameters(
                idx,
                parameters,
                normalizedSigma,
                kappa,
                normalizedAlpha
            );
            // Taflove 3rd ed. (7.102)
            damping = math::exp( -( normalizedSigma / kappa + normalizedAlpha ) * dt );
            diff = float3_X::create( dt );
            for ( auto dim = 0; dim < 3; dim++ )
                if( normalizedSigma[ dim ] )
                    diff[ dim ] = normalizedSigma[ dim ] * ( damping[ dim ] - 1.0_X ) /
                        ( kappa[ dim ] * EPS0 * ( normalizedSigma[ dim ] +
                        normalizedAlpha[ dim ] * kappa[ dim ] ) );
        }

        DINLINE bool isInPML( float3_X const damping )
        {
            /* Each damping component is < 1 when absorption is enabled
             * along this direction and == 1 otherwise.
             * So a product is 1 in the internal area and < 1 in PML
             */
            return damping.x() * damping.y() * damping.z() != 1.0_X;
        }

    } // namespace detail

    /** compute electric field
     *
     * @tparam T_numWorkers number of workers
     * @tparam T_BlockDescription field (electric and magnetic) domain description
     */
    template<
        uint32_t T_numWorkers,
        typename T_BlockDescription
    >
    struct KernelUpdateE
    {
        /** update electric field
         *
         * @tparam T_Curl curl functor type
         * @tparam T_EBox pmacc::DataBox, electric field box type
         * @tparam T_PMLEBox PML split electric field box type
         * @tparam T_BBox pmacc::DataBox, magnetic field box type
         * @tparam T_Mapping mapper functor type
         * @tparam T_Acc alpaka accelerator type
         *
         * @param acc alpaka accelerator
         * @param curl functor to calculate the electric field, interface must be
         *             `operator()(T_BBox)`
         * @param fieldE electric field iterator
         * @param fieldB magnetic field iterator
         * @param mapper functor to map a block to a supercell
         */
        template<
            typename T_Curl,
            typename T_PMLEBox,
            typename T_EBox,
            typename T_BBox,
            typename T_Mapping,
            typename T_Acc
        >
        DINLINE void operator()(
            T_Acc const & acc,
            T_Curl const curl,
            T_PMLEBox psiE,
            T_EBox fieldE,
            T_BBox const fieldB,
            T_Mapping mapper,
            LocalParameters parameters
        ) const
        {
            // All numbers, offsets and indexes in this kernel include guard
            // local index (inside the local domain), including guards
            // starting cell index in the current supercell
            auto const startCellIdx = mapper.getSuperCellIndex(
                DataSpace< simDim >( blockIdx ) ) * MappingDesc::SuperCellSize::toRT( );

            // Cache B values for the block
            using namespace mappings::threads;
            constexpr uint32_t numWorkers = T_numWorkers;
            uint32_t const workerIdx = threadIdx.x;
            nvidia::functors::Assign assign;
            auto fieldBBlock = fieldB.shift( startCellIdx );
            ThreadCollective<
                T_BlockDescription,
                numWorkers
            > collectiveCacheB( workerIdx );
            auto cachedB = CachedBox::create<
                0u,
                typename T_BBox::ValueType
            >(
                acc,
                T_BlockDescription( )
            );
            collectiveCacheB(
                acc,
                assign,
                cachedB,
                fieldBBlock
            );
            __syncthreads();

            constexpr float_X c2 = SPEED_OF_LIGHT * SPEED_OF_LIGHT;
            constexpr float_X dt = DELTA_T;

            // Parallel processing of cells
            constexpr uint32_t numCellsPerSuperCell =
                pmacc::math::CT::volume< SuperCellSize >::type::value;
            ForEachIdx<
                IdxConfig<
                    numCellsPerSuperCell,
                    numWorkers
                >
            >{ workerIdx }(
                [&](
                    uint32_t const linearIdx,
                    uint32_t const
                )
                {
                    // cellIdx is cell index in local domain
                    DataSpace< simDim > const cellIdxInSuperCell = DataSpaceOperations< simDim >::template map< SuperCellSize >( linearIdx );
                    auto cellIdx = startCellIdx + cellIdxInSuperCell;

                    float3_X kappa, damping, diff;
                    auto const pmlIdx = precisionCast< float_X >( cellIdx );
                    detail::getCoefficients(
                        pmlIdx,
                        parameters,
                        dt,
                        kappa,
                        damping,
                        diff
                    );

                    if( detail::isInPML( damping ) )
                    {
                        // Update split fields
                        using Difference = typename T_Curl::Difference;
                        const typename Difference::template GetDifference< 0 > Dx;
                        const typename Difference::template GetDifference< 1 > Dy;
                        const typename Difference::template GetDifference< 2 > Dz;
                        auto const localB = cachedB.shift( cellIdxInSuperCell );
                        auto const dBxDy = Dy( localB ).x( );
                        auto const dBxDz = Dz( localB ).x( );
                        auto const dByDx = Dx( localB ).y( );
                        auto const dByDz = Dz( localB ).y( );
                        auto const dBzDx = Dx( localB ).z( );
                        auto const dBzDy = Dy( localB ).z( );
                        psiE( cellIdx ).yx = damping.x() * psiE( cellIdx ).yx - diff.x() * dBzDx;
                        psiE( cellIdx ).zx = damping.x() * psiE( cellIdx ).zx + diff.x() * dByDx;
                        psiE( cellIdx ).xy = damping.y() * psiE( cellIdx ).xy + diff.y() * dBzDy;
                        psiE( cellIdx ).zy = damping.y() * psiE( cellIdx ).zy - diff.y() * dBxDy;
                        psiE( cellIdx ).xz = damping.z() * psiE( cellIdx ).xz - diff.z() * dByDz;
                        psiE( cellIdx ).yz = damping.z() * psiE( cellIdx ).yz + diff.z() * dBxDz;
                        // Update full fields
                        fieldE( cellIdx ).x() += (dBzDy / kappa.y() - dByDz / kappa.z() +
                            psiE( cellIdx ).xy - psiE( cellIdx ).xz ) * c2 * dt;
                        fieldE( cellIdx ).y() += (dBxDz / kappa.z() - dBzDx / kappa.x() +
                            psiE( cellIdx ).yz - psiE( cellIdx ).yx ) * c2 * dt;
                        fieldE( cellIdx ).z() += (dByDx / kappa.x() - dBxDy / kappa.y() +
                            psiE( cellIdx ).zx - psiE( cellIdx ).zy ) * c2 * dt;
                    }
                    else
                        fieldE( cellIdx ) += curl( cachedB.shift( cellIdxInSuperCell ) ) * c2 * dt;
                }
            );
        }
    };

    /** Update magnetic field
     *
     * @tparam T_numWorkers number of workers
     * @tparam T_BlockDescription field (electric and magnetic) domain description
     */
    template<
        uint32_t T_numWorkers,
        typename T_BlockDescription
    >
    struct KernelUpdateBHalf
    {
        /** update magnetic field
         *
         * @tparam T_Curl curl functor type
         * @tparam T_EBox pmacc::DataBox, electric field box type
         * @tparam T_BBox pmacc::DataBox, magnetic field box type
         * @tparam T_PMLBBox PML split magnetic field box type
         * @tparam T_Mapping mapper functor type
         * @tparam T_Acc alpaka accelerator type
         *
         * @param acc alpaka accelerator
         * @param curl functor to calculate the electric field, interface must be
         *             `operator()(T_EBox)`
         * @param fieldB magnetic field iterator
         * @param fieldE electric field iterator
         * @param mapper functor to map a block to a supercell
         */
        template<
            typename T_Curl,
            typename T_PMLBBox,
            typename T_EBox,
            typename T_BBox,
            typename T_Mapping,
            typename T_Acc
        >
        DINLINE void operator()(
            T_Acc const & acc,
            T_Curl const curl,
            T_PMLBBox psiB,
            T_BBox fieldB,
            T_EBox const fieldE,
            T_Mapping mapper,
            LocalParameters parameters
        ) const
        {
            // All numbers, offsets and indexes in this kernel include guard
            // local index (inside the local domain), including guards
            DataSpace< simDim > const superCellIdx( mapper.getSuperCellIndex( DataSpace< simDim >( blockIdx ) ) );
            // starting cell index in the current supercell
            DataSpace< simDim > const startCellIdx = superCellIdx * MappingDesc::SuperCellSize::toRT();

            // Cache E values for the block
            using namespace mappings::threads;
            constexpr uint32_t numWorkers = T_numWorkers;
            uint32_t const workerIdx = threadIdx.x;
            nvidia::functors::Assign assign;
            auto fieldEBlock = fieldE.shift( startCellIdx );
            ThreadCollective<
                T_BlockDescription,
                numWorkers
            > collectiveCacheE( workerIdx );
            auto cachedE = CachedBox::create<
                0u,
                typename T_EBox::ValueType
            >(
                acc,
                T_BlockDescription()
            );
            collectiveCacheE(
                acc,
                assign,
                cachedE,
                fieldEBlock
            );
            __syncthreads();

            // Parallel processing of cells
            constexpr uint32_t numCellsPerSuperCell = pmacc::math::CT::volume< SuperCellSize >::type::value;
            ForEachIdx<
                IdxConfig<
                    numCellsPerSuperCell,
                    numWorkers
                >
            >{ workerIdx }(
                [&](
                    uint32_t const linearIdx,
                    uint32_t const
                )
                {
                    // cellIdx is cell index in local domain
                    DataSpace< simDim > const cellIdxInSuperCell = DataSpaceOperations< simDim >::template map< SuperCellSize >( linearIdx );
                    auto cellIdx = startCellIdx + cellIdxInSuperCell;

                    constexpr float_X halfDt = 0.5_X * DELTA_T;
                    float3_X kappa, damping, diff;
                    // With the current grid for B need to shift by a half cell
                    auto const pmlIdx = float3_X::create( 0.5_X ) +
                        precisionCast< float_X >( cellIdx );
                    detail::getCoefficients(
                        pmlIdx,
                        parameters,
                        halfDt,
                        kappa,
                        damping,
                        diff
                    );

                    if( detail::isInPML( damping ) )
                    {
                        // Update PML fields
                        using Difference = typename T_Curl::Difference;
                        const typename Difference::template GetDifference< 0 > Dx;
                        const typename Difference::template GetDifference< 1 > Dy;
                        const typename Difference::template GetDifference< 2 > Dz;
                        auto const localE = cachedE.shift( cellIdxInSuperCell );
                        auto const dExDy = Dy( localE ).x( );
                        auto const dExDz = Dz( localE ).x( );
                        auto const dEyDx = Dx( localE ).y( );
                        auto const dEyDz = Dz( localE ).y( );
                        auto const dEzDx = Dx( localE ).z( );
                        auto const dEzDy = Dy( localE ).z( );
                        psiB( cellIdx ).yx = damping.x() * psiB( cellIdx ).yx + diff.x() * dEzDx;
                        psiB( cellIdx ).zx = damping.x() * psiB( cellIdx ).zx - diff.x() * dEyDx;
                        psiB( cellIdx ).xy = damping.y() * psiB( cellIdx ).xy - diff.y() * dEzDy;
                        psiB( cellIdx ).zy = damping.y() * psiB( cellIdx ).zy + diff.y() * dExDy;
                        psiB( cellIdx ).xz = damping.z() * psiB( cellIdx ).xz + diff.z() * dEyDz;
                        psiB( cellIdx ).yz = damping.z() * psiB( cellIdx ).yz - diff.z() * dExDz;
                        // Update full fields
                        fieldB( cellIdx ).x() += ( dEyDz / kappa.z() - dEzDy / kappa.y() +
                            psiB( cellIdx ).xz - psiB( cellIdx ).xy ) * halfDt;
                        fieldB( cellIdx ).y() += ( dEzDx / kappa.x() - dExDz / kappa.z() +
                            psiB( cellIdx ).yx - psiB( cellIdx ).yz ) * halfDt;
                        fieldB( cellIdx ).z() += ( dExDy / kappa.y() - dEyDx / kappa.x() +
                            psiB( cellIdx ).zy - psiB( cellIdx ).zx ) * halfDt;
                    }
                    else
                        fieldB( cellIdx ) -= curl( cachedE.shift( cellIdxInSuperCell ) ) * halfDt;
                }
            );
        }
    };

} // namespace yeePML
} // namespace maxwellSolver
} // namespace fields
} // namespace picongpu
